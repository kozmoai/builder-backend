package model

import (
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/kozmoai/builder-backend/src/utils/idconvertor"
)

type AppActivity struct {
	Modifier   string    `json:"modifier"`
	ModifiedAt time.Time `json:"modifiedAt"`
}

func NewAppActivity() *AppActivity {
	return &AppActivity{}
}

func NewAppActivityWithPayload(userName string, updatedAt time.Time) *AppActivity {
	return &AppActivity{
		Modifier:   userName,
		ModifiedAt: updatedAt,
	}
}

type AppForExport struct {
	ID              string              `json:"appId"` // generated by database primary key serial
	UID             uuid.UUID           `json:"uid"`
	TeamID          string              `json:"teamID"`
	Name            string              `json:"appName" validate:"required"`
	ReleaseVersion  int                 `json:"releaseVersion"`  // release version used for mark the app release version.
	MainlineVersion int                 `json:"mainlineVersion"` // mainline version keep the newest app version in database.
	Deployed        bool                `json:"deployed"`
	Config          *AppConfigForExport `json:"config"`
	CreatedBy       string              `json:"-" `
	CreatedAt       time.Time           `json:"-"`
	UpdatedBy       string              `json:"updatedBy"`
	UpdatedAt       time.Time           `json:"updatedAt"`
	AppActivity     *AppActivity        `json:"appActivity"`
	EditedBy        []*UserForEditedBy  `json:"editedBy"`
}

func (appForExport *AppForExport) CalculateIsDeployed() {
	appForExport.Deployed = false
	if appForExport.ReleaseVersion > 0 {
		appForExport.Deployed = true
	}
}

func NewAppForExport(a *App, usersLT map[int]*User) *AppForExport {
	// construct app activity
	user, hit := usersLT[a.ExportUpdatedBy()]
	appActivity := NewAppActivity()
	if hit {
		appActivity = NewAppActivityWithPayload(user.Nickname, a.ExportUpdatedAt())
	}
	// construct edited by
	appEditedBys := a.ExportEditedBy()
	editedByUsers := make([]*UserForEditedBy, 0)
	for _, appEditedBy := range appEditedBys {
		if appEditedBy == nil {
			continue
		}
		userID := appEditedBy.UserID
		user, hit := usersLT[userID]
		if !hit {
			continue
		}
		editedByUser := NewUserForEditedBy(user, appEditedBy.EditedAt)
		editedByUsers = append(editedByUsers, editedByUser)
	}
	// feedback
	ret := &AppForExport{
		ID:              idconvertor.ConvertIntToString(a.ID),
		UID:             a.UID,
		TeamID:          idconvertor.ConvertIntToString(a.TeamID),
		Name:            a.Name,
		ReleaseVersion:  a.ReleaseVersion,
		MainlineVersion: a.MainlineVersion,
		Config:          NewAppConfigForExportWithoutComponentsAndActions(a.ExportConfig()),
		CreatedBy:       idconvertor.ConvertIntToString(a.CreatedBy),
		CreatedAt:       a.CreatedAt,
		UpdatedBy:       idconvertor.ConvertIntToString(a.UpdatedBy),
		UpdatedAt:       a.UpdatedAt,
		AppActivity:     appActivity,
		EditedBy:        editedByUsers,
	}
	ret.CalculateIsDeployed()
	return ret
}

func NewAppForExportWithFullConfigInfo(a *App, usersLT map[int]*User, treeStates []*TreeState, actions []*Action) *AppForExport {
	// construct app activity
	user, hit := usersLT[a.ExportUpdatedBy()]
	appActivity := NewAppActivity()
	if hit {
		appActivity = NewAppActivityWithPayload(user.Nickname, a.ExportUpdatedAt())
	}
	// construct edited by
	appEditedBys := a.ExportEditedBy()
	editedByUsers := make([]*UserForEditedBy, 0)
	for _, appEditedBy := range appEditedBys {
		if appEditedBy == nil {
			continue
		}
		userID := appEditedBy.UserID
		user, hit := usersLT[userID]
		if !hit {
			continue
		}
		editedByUser := NewUserForEditedBy(user, appEditedBy.EditedAt)
		editedByUsers = append(editedByUsers, editedByUser)
	}
	// feedback
	ret := &AppForExport{
		ID:              idconvertor.ConvertIntToString(a.ID),
		UID:             a.UID,
		TeamID:          idconvertor.ConvertIntToString(a.TeamID),
		Name:            a.Name,
		ReleaseVersion:  a.ReleaseVersion,
		MainlineVersion: a.MainlineVersion,
		Config:          NewAppConfigForExport(a.ExportConfig(), treeStates, actions),
		CreatedBy:       idconvertor.ConvertIntToString(a.CreatedBy),
		CreatedAt:       a.CreatedAt,
		UpdatedBy:       idconvertor.ConvertIntToString(a.UpdatedBy),
		UpdatedAt:       a.UpdatedAt,
		AppActivity:     appActivity,
		EditedBy:        editedByUsers,
	}
	ret.CalculateIsDeployed()
	return ret
}

func NewAppForExportByMap(data interface{}) (*AppForExport, error) {
	udata, ok := data.(map[string]interface{})
	if !ok {
		err := errors.New("NewAppForExportByMap failed, please check your input.")
		return nil, err
	}
	name, mapok := udata["name"].(string)
	if !mapok {
		err := errors.New("NewAppForExportByMap failed, can not find name field.")
		return nil, err
	}
	// fill field
	appForExport := &AppForExport{
		Name: name,
	}
	return appForExport, nil
}

func (resp *AppForExport) ExportName() string {
	return resp.Name
}

func (resp *AppForExport) ExportForFeedback() interface{} {
	return resp
}
